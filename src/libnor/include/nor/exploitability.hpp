
#ifndef NOR_EXPLOITABILITY_HPP
#define NOR_EXPLOITABILITY_HPP

#include "nor/concepts.hpp"
#include "nor/factory.hpp"
#include "nor/fosg_traits.hpp"
#include "nor/game_defs.hpp"
#include "nor/rm/policy_value.hpp"

// nash-conv = sum_i u_i(BR(pi_{-i}), pi_{-i}) - u_i(pi)
// exploitability = nash-conv / N

namespace nor {

template < typename Env, typename Policy >
   requires concepts::fosg< std::remove_cvref_t< Env > >
            and concepts::state_policy_view<
               Policy,
               auto_info_state_type< std::remove_cvref_t< Env > >,
               auto_action_type< std::remove_cvref_t< Env > > >
double nash_conv(
   Env&& env,
   const auto_world_state_type< std::remove_cvref_t< Env > >& root_state,
   const player_hashmap< Policy >& player_policies,
   bool constant_sum = false
)
{
   using env_type = std::remove_cvref_t< Env >;
   using info_state_type = auto_info_state_type< env_type >;
   using action_type = auto_action_type< env_type >;

   double value_out = 0.;
   auto all_players = env.players(root_state);
   std::erase(all_players, Player::chance);
   for(const auto& [best_responder, policy] : player_policies) {
      auto best_response = nor::factory::make_best_response_policy< info_state_type, action_type >(
         best_responder
      );
      best_response.allocate(env, root_state, player_policies);

      value_out += rm::policy_value(env, root_state, std::invoke([&] {
                                       auto policy_map = player_hashmap<
                                          StatePolicyView< info_state_type, action_type > >{
                                          std::pair{best_responder, StatePolicyView{best_response}}
                                       };
                                       for(auto player : all_players) {
                                          if(player != best_responder) {
                                             policy_map.emplace(
                                                player, StatePolicyView{player_policies.at(player)}
                                             );
                                          }
                                       }
                                       return policy_map;
                                    }))
                      .get()
                      .at(best_responder);
   }
   if(not constant_sum) {
      // if we are not in a constant sum case (or we simply want to include the constant value in
      // our output value for better referencing), then we have to compute the policy profile's
      // value for each player and subtract that from the current nash conv sum
      auto policy_value_map = rm::policy_value(env, root_state, player_policies);
      value_out += ranges::accumulate(
         policy_value_map.get() | ranges::views::values, double(0.), std::minus{}
      );
   }
   return value_out;
}

template < typename Env, typename Policy >
double exploitability(
   Env&& env,
   const auto_world_state_type< std::remove_cvref_t< Env > >& root_state,
   const player_hashmap< Policy >& player_policies,
   bool constant_sum = false
)
{
   auto players = env.players(root_state);
   // the chance player is not an active participant, thus exploitability does not include for it
   std::erase(players, Player::chance);
   return nash_conv(std::forward< Env >(env), root_state, player_policies, constant_sum)
          / double(players.size());
}

}  // namespace nor
#endif  // NOR_EXPLOITABILITY_HPP
