
#ifndef NOR_EXPLOITABILITY_HPP
#define NOR_EXPLOITABILITY_HPP

#include "nor/fosg_traits.hpp"
#include "nor/game_defs.hpp"
#include "nor/concepts.hpp"
#include "nor/factory.hpp"
#include "nor/rm/policy_value.hpp"

// nash-conv = sum_i u(policy_i, BR_{-i}(policy_i)) - GameValue_i
// exploitability = nash-conv / N

namespace nor {

template < typename Env, typename Policy >
   requires concepts::state_policy_view<
      Policy,
      auto_info_state_type< std::remove_cvref_t< Env > >,
      auto_action_type< std::remove_cvref_t< Env > > >
double nash_conv(
   Env&& env,
   const auto_world_state_type< std::remove_cvref_t< Env > >& root_state,
   const player_hash_map< Policy >& player_policies
)
{
   using env_type = std::remove_cvref_t< Env >;
   using info_state_type = auto_info_state_type< env_type >;
   using action_type = auto_action_type< env_type >;

   double value_out = 0.;
   auto all_players = env.players(root_state);
   for(const auto& [player, policy] : player_policies) {
      auto best_responders = all_players;
      std::erase(best_responders, player);
      auto best_response = nor::factory::make_best_response_policy< info_state_type, action_type >(
         best_responders
      );
      best_response.allocate(env, player_policies, root_state);

      value_out +=
         rm::policy_value(
            env, root_state, std::invoke([&] {
               auto policy_map = std::unordered_map{std::pair{player, player_policies.at(player)}};
               for(auto br_player : best_responders) {
                  policy_map.emplace(br_player, StatePolicyView{best_response});
               }
               return policy_map;
            })
         )
            .get()
            .at(player);
   }
   return value_out;
}

template < typename Env, typename Policy >
double exploitability(
   Env&& env,
   const auto_world_state_type< std::remove_cvref_t< Env > >& root_state,
   const player_hash_map< Policy >& player_policies
)
{
   return nash_conv(env, root_state, player_policies) / env.players(root_state).size();
}

}  // namespace nor
#endif  // NOR_EXPLOITABILITY_HPP
