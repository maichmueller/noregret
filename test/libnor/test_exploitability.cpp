
#include <gtest/gtest.h>

#include <random>
#include <string>

#include "common/common.hpp"
#include "nor/exploitability.hpp"
#include "nor/fosg_traits.hpp"
#include "nor/game_defs.hpp"
#include "rm_specific_testing_utils.hpp"

class Exploitability_KuhnPoker_ParamsF:
    public ::testing::TestWithParam<  //
       std::tuple<  //
          std::string,  // test case description
          nor::player_hash_map< nor::TabularPolicy<
             nor::games::kuhn::Infostate,
             nor::HashmapActionPolicy< nor::games::kuhn::Action > > >,  // the input policies
          double  // the exploitability expected
          > > {};

TEST_P(Exploitability_KuhnPoker_ParamsF, basic_policies_exploitability)
{
   using namespace nor::games::kuhn;
   auto [_, policies, expected_expl] = GetParam();
   double expl = nor::exploitability(
      Environment{},
      State{},
      std::unordered_map{
         std::pair{
            nor::Player::alex,
            nor::factory::make_tabular_policy(std::move(policies.at(nor::Player::alex)))},
         std::pair{
            nor::Player::bob,
            nor::factory::make_tabular_policy(std::move(policies.at(nor::Player::bob)))}}
   );
   EXPECT_NEAR(expl, expected_expl, 1e-8);
}

// exploitability expected values are produced via existing implementations of similar frameworks
INSTANTIATE_TEST_SUITE_P(
   all,
   Exploitability_KuhnPoker_ParamsF,
   testing::ValuesIn(std::invoke([] {
      auto [optimal_alex, optimal_bob] = kuhn_optimal(0.);
      auto [uniform_alex, uniform_bob] = kuhn_policy_always_mix_like(0.5, 0.5);
      auto [always_check_alex, always_check_bob] = kuhn_policy_always_mix_like(1., 0.);
      auto [always_bet_alex, always_bet_bob] = kuhn_policy_always_mix_like(0., 1.);

      return std::vector{
         std::tuple{
            std::string("optimal_policies"),
            std::unordered_map{
               std::pair{nor::Player::alex, optimal_alex},
               std::pair{nor::Player::bob, optimal_bob}},
            0.  // the expected expl value
         },
         std::tuple{
            std::string("uniform_policies"),
            std::unordered_map{
               std::pair{nor::Player::alex, uniform_alex},
               std::pair{nor::Player::bob, uniform_bob}},
            (0.9 + 1. / 60.) / 2.  // the expected expl value
         },
         std::tuple{
            std::string("always_check_policies"),
            std::unordered_map{
               std::pair{nor::Player::alex, always_check_alex},
               std::pair{nor::Player::bob, always_check_bob}},
            1.  // the expected expl value
         },
         std::tuple{
            std::string("always_bet_policies"),
            std::unordered_map{
               std::pair{nor::Player::alex, always_bet_alex},
               std::pair{nor::Player::bob, always_bet_bob}},
            1. / 3.  // the expected expl value
         }};
   })),
   [](const auto& params) { return std::get< 0 >(params.param); }
);
